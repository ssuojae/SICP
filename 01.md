
## 01. Building Abstractions with Functions

<br/>

> 1. Combining several simple ideas into one compound one, and
thus all complex ideas are made. 
>2. The second is bringing two ideas, whether
simple or complex, together, and setting them by one another so as to take a
view of them at once, without uniting them into one, by which it gets all its
ideas of relations. 
>3. The third is separating them from all other ideas that
accompany them in their real existence: this is called abstraction, and thus all
its general ideas are made.

- 아무리 복잡한 아이디어도 결국 작은 단위의 로직의 조합이다. 
- 추상화라는 것은 본질만 남기는 것이다. 

<br/>

```javascript
// Applicative order
//  3 + 2가 먼저 계산되어 5가 되고, 그 다음 함수 sum_of_squares는 5와 4라는 값을 받아서 실행
function square(x) {
    console.log('Calculating square of', x);
    return x * x;
}

function sum_of_squares(x, y) {
    return square(x) + square(y);
}

console.log(sum_of_squares(3 + 2, 4));

// Normal Order
// 3 + 2와 4를 함수로 감싸서 전달하고, square(x)가 호출될 때 x()를 실행해서 그때서야 값 계산 (지연평가)
function square(x) {
    console.log('Calculating square of', x());
    return x() * x();
}

function sum_of_squares(x, y) {
    return square(x) + square(y);
}

console.log(sum_of_squares(() => 3 + 2, () => 4));

```

- **Applicative order**는 인자를 미리 계산한 후 함수에 전달한다.
- **Normal order**는 함수가 필요할 때만 계산하기 때문에, 일부 계산을 생략할 수 있을 때 유리하다. 하지만 중복 계산이 발생할 수 있다.
- 이부분읽자마자 들었던 생각은 Applicative order는 절차형이고 Normal order는 함수형에 가까운 연산 방식이라는 것이다. 퍙가 방식의 차이가 프로그래밍 패러다임과 자연스럽게 연결되는 점이 매우 흥미로웠던 부분
- Normal order는 구조상 함수로 지연평가가 되면서 이벤트 반응형 프로그래밍에 적합하다는 것을 알 수 있다.


